<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Carte Mapbox avec Mise à Jour depuis Bubble</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">

    <!-- Inclusion des feuilles de style et scripts Mapbox -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>

    <!-- Style personnalisé pour la carte -->
    <style>
        body { margin: 0; padding: 0; font-family: 'Inter', sans-serif; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
    </style>
</head>
<body>

    <!-- Conteneur de la carte -->
    <div id="map"></div>

    <!-- Script principal -->
    <script>
        // Variable globale pour la carte
        let map;

        // Initialisation de la carte lorsque la page est chargée
        window.onload = function() {
            mapboxgl.accessToken = 'pk.eyJ1IjoiaGFkcmllbmxlZ2VyIiwiYSI6ImNsYm1oc3RidzA1NDczdm1xYTJmc3cwcm4ifQ.AguFBTkyTxFnz3VWFBSjrA'; // Remplacez par votre propre token

            // Création de la carte
            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/streets-v12',
                center: [2.33, 48.86], // Centre initial (Paris)
                zoom: 11,
                doubleClickZoom: true
            });

            // Une fois la carte chargée
            map.on('load', function() {
                // Vous pouvez ajouter ici d'autres couches ou configurations initiales si nécessaire
            });
        };

        // Fonction appelée depuis Bubble pour mettre à jour la carte
        window.bubble_fn_updateMap = function(latitude, longitude, radius) {
            if (map) {
                // Conversion des paramètres en nombres
                latitude = parseFloat(latitude);
                longitude = parseFloat(longitude);
                radius = parseFloat(radius);

                // Vérification des valeurs
                if (isNaN(latitude) || isNaN(longitude) || isNaN(radius)) {
                    console.error('Paramètres invalides pour bubble_fn_updateMap');
                    return;
                }

                // Centrer la carte sur les coordonnées spécifiées
                map.flyTo({ center: [longitude, latitude], zoom: 13 });

                // Supprimer le cercle existant s'il y en a un
                if (map.getSource('search-circle')) {
                    if (map.getLayer('search-circle')) {
                        map.removeLayer('search-circle');
                    }
                    map.removeSource('search-circle');
                }

                // Créer le GeoJSON du cercle
                var circleGeoJSON = createGeoJSONCircle([longitude, latitude], radius);

                // Ajouter le cercle à la carte
                map.addSource('search-circle', {
                    'type': 'geojson',
                    'data': circleGeoJSON
                });

                map.addLayer({
                    'id': 'search-circle',
                    'type': 'fill',
                    'source': 'search-circle',
                    'layout': {},
                    'paint': {
                        'fill-color': '#007cbf',
                        'fill-opacity': 0.2
                    }
                });
            } else {
                console.log('La carte n\'est pas encore initialisée');
            }
        };

        // Fonction pour créer un cercle en GeoJSON
        function createGeoJSONCircle(center, radiusInKm, points) {
            if (!points) points = 64;

            var coords = {
                latitude: center[1],
                longitude: center[0]
            };

            var km = radiusInKm;

            var ret = [];
            var distanceX = km / (111.320 * Math.cos(coords.latitude * Math.PI / 180));
            var distanceY = km / 110.574;

            var theta, x, y;
            for (var i = 0; i < points; i++) {
                theta = (i / points) * (2 * Math.PI);
                x = distanceX * Math.cos(theta);
                y = distanceY * Math.sin(theta);

                ret.push([coords.longitude + x, coords.latitude + y]);
            }
            ret.push(ret[0]);

            return {
                "type": "Feature",
                "geometry": {
                    "type": "Polygon",
                    "coordinates": [ret]
                }
            };
        }
    </script>
</body>
</html>
