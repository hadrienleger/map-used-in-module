<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Carte Mapbox avec sélection des communes et départements</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">

  <!-- Inclusion des feuilles de style et scripts Mapbox -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>

  <!-- Style personnalisé pour la carte -->
  <style>
    body { margin: 0; padding: 0; font-family: 'Inter', sans-serif; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }
    .legend {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 4px;
        font-size: 12px;
    }
    .legend-item {
        display: flex;
        align-items: center;
        margin: 5px 0;
    }
    .legend-color {
        width: 20px;
        height: 20px;
        margin-right: 5px;
    }

  </style>
</head>
<body>

  <!-- Conteneur de la carte -->
  <div id="map"></div>

  <!-- Script principal -->
  <script>

/****************************************************
 * Code principal JavaScript pour la carte Mapbox
 * ----------------------------------------------
 * 1) On a un `layerConfigs` décrivant chaque couche.
 * 2) Au chargement de la carte, on ajoute les sources (map.on('load')).
 * 3) On a des fonctions addLayer() qui gèrent 
 *    - 'selectable' 
 *    - 'choropleth' 
 *    - 'filterable' (ex. carreaux 200m)
 * 4) On a hideAllLayers() pour cacher toutes les couches si besoin.
 * 5) On a des fonctions publiques (window.xxx) 
 *    que Bubble peut appeler via "Run JavaScript".
 ****************************************************/

let map;
let selectedFeatures = [];  // stocke les codes insee sélectionnés (pour communes/départ)
let currentLayerType = 'none'; // ex. 'com', 'dep', 'niveauVie', etc.

// Configuration "unifiée" des différentes couches
const layerConfigs = {

  // Couche SELECTABLE: communes
  communes: {
    type: 'selectable',
    source: {
      type: 'vector',
      url: 'mapbox://hadrienleger.cya562rc'
    },
    sourceLayer: 'simplifie-fusion-communes-et--439qo9',
    paint: {
      'fill-color': [
        'case',
        ['boolean', ['feature-state', 'selected'], false],
        '#FF0000',
        '#2C3E50'
      ],
      'fill-opacity': 0.8,
      'fill-outline-color': '#FFFFFF'
    },
    // ID property => ex. 'INSEE_COM'
    interactions: {
      selectable: true,
      idField: 'INSEE_COM',
      cursor: 'pointer',
      bubbleFunction: 'com'
    }
  },

  // Couche SELECTABLE: départements
  departements: {
    type: 'selectable',
    source: {
      type: 'vector',
      url: 'mapbox://hadrienleger.7ys4ypx4'
    },
    sourceLayer: 'simplifie-DEPARTEMENT-asio6w',
    paint: {
      'fill-color': [
        'case',
        ['boolean', ['feature-state', 'selected'], false],
        '#FF0000',
        '#8E44AD'
      ],
      'fill-opacity': 0.5,
      'fill-outline-color': '#FFFFFF'
    },
    interactions: {
      selectable: true,
      idField: 'INSEE_DEP',
      cursor: 'pointer',
      bubbleFunction: 'dep'
    }
  },

  // Couche CHOROPLETH: ex. niveauVie
  niveauVie: {
    type: 'choropleth',
    source: {
      type: 'vector',
      url: 'mapbox://hadrienleger.filosofi2019'
    },
    sourceLayer: 'hadrienleger.filosofi2019',
    property: 'nv_moyen', 
    breaks: [15000, 20000, 25000, 30000, 35000],
    colors: ['#fee5d9', '#fcae91', '#fb6a4a', '#de2d26', '#a50f15', '#67000d'],
    title: 'Niveau de vie médian'
  },

  // Couche CHOROPLETH: ex. part_log_soc
  logementSocial: {
    type: 'choropleth',
    source: {
      type: 'vector',
      url: 'mapbox://hadrienleger.filosofi2019'
    },
    sourceLayer: 'hadrienleger.filosofi2019',
    property: 'part_log_soc',
    breaks: [5, 10, 15, 20, 25],
    colors: ['#eff3ff', '#bdd7e7', '#6baed6', '#3182bd', '#08519c', '#042f6b'],
    title: 'Part de logements sociaux (%)'
  },

  // Couche FILTERABLE: pour les carreaux de 200m
  carresResult: {
    type: 'filterable',
    source: {
      type: 'vector',
      url: 'mapbox://hadrienleger.grille200m' // ton tileset MBTiles
    },
    sourceLayer: 'grid200m_source_layer', // à adapter au nom exact
    paint: {
      'fill-color': '#FF0000',
      'fill-opacity': 0.5
    },
    idField: 'IDINSPIRE' // le champ d'ID (ex: "CRS3035RES200mN2893400E3756600")
  }

};

// ----------------------
//  Initialisation carte
// ----------------------
function initializeMap() {
  mapboxgl.accessToken = 'pk.eyJ1IjoiaGFkcmllbmxlZ2VyIiwiYSI6ImNsYm1oc3RidzA1NDczdm1xYTJmc3cwcm4ifQ.AguFBTkyTxFnz3VWFBSjrA';

  map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/light-v11',
    center: [2.2137, 46.2276],
    zoom: 5
  });

  map.on('load', () => {
    // Ajouter toutes les sources
    Object.keys(layerConfigs).forEach(layerId => {
      if (!map.getSource(layerId)) {
        map.addSource(layerId, layerConfigs[layerId].source);
      }
    });

    // On n’ajoute pas forcément toutes les couches d’emblée
    // En tout cas on les cache / ou on attend l’appel "addLayer" pour les activer
  });
}

// ----------------------------------------------------------------------------
// Fonctions d'ajout de couches
// ----------------------------------------------------------------------------

function addLayer(layerId) {
  const config = layerConfigs[layerId];
  if (!config) return;

  switch (config.type) {
    case 'selectable':
      addSelectableLayer(layerId, config);
      break;
    case 'choropleth':
      addChoroplethLayer(layerId, config);
      break;
    case 'filterable':
      addFilterableLayer(layerId, config);
      break;
  }
}

function addSelectableLayer(layerId, config) {
  // Ajouter la couche si elle n’existe pas
  if (!map.getLayer(layerId)) {
    map.addLayer({
      id: layerId,
      type: 'fill',
      source: layerId,
      'source-layer': config.sourceLayer,
      paint: config.paint
    });
  }
  
  // Gérer la sélection
  if (config.interactions?.selectable) {
    map.on('click', layerId, (e) => {
      handleFeatureClick(e, layerId);
    });

    if (config.interactions.cursor) {
      map.on('mouseenter', layerId, () => {
        map.getCanvas().style.cursor = config.interactions.cursor;
      });
      map.on('mouseleave', layerId, () => {
        map.getCanvas().style.cursor = '';
      });
    }
  }
}

function handleFeatureClick(e, layerId) {
  const config = layerConfigs[layerId];
  const feature = e.features[0];
  const id = feature.properties[config.interactions.idField];
  
  // Toggle
  const idx = selectedFeatures.indexOf(id);
  if (idx > -1) {
    selectedFeatures.splice(idx, 1);
    map.setFeatureState(
      { source: layerId, sourceLayer: config.sourceLayer, id: feature.id },
      { selected: false }
    );
  } else {
    selectedFeatures.push(id);
    map.setFeatureState(
      { source: layerId, sourceLayer: config.sourceLayer, id: feature.id },
      { selected: true }
    );
  }

  // Envoyer liste à Bubble
  if (typeof bubble_fn_selectedFeatures === 'function') {
    bubble_fn_selectedFeatures({
      output1: config.interactions.bubbleFunction,
      outputlist1: selectedFeatures
    });
  }
}

function addChoroplethLayer(layerId, config) {
  const layerIdFull = `${layerId}-choropleth`;
  if (!map.getLayer(layerIdFull)) {
    // Construire l'expression color
    const colorExpr = ['step', ['get', config.property]];
    config.breaks.forEach((brk, i) => {
      colorExpr.push(brk);
      colorExpr.push(config.colors[i]);
    });
    colorExpr.push(config.colors[config.colors.length - 1]);

    map.addLayer({
      id: layerIdFull,
      type: 'fill',
      source: layerId,
      'source-layer': config.sourceLayer,
      paint: {
        'fill-color': colorExpr,
        'fill-opacity': 0.7,
        'fill-outline-color': '#ffffff'
      }
    });
  }
}

function addFilterableLayer(layerId, config) {
  // Ajouter la couche si pas déjà existante
  if (!map.getLayer(layerId)) {
    map.addLayer({
      id: layerId,
      type: 'fill',
      source: layerId,
      'source-layer': config.sourceLayer,
      paint: config.paint
    });
  }
  // A la base, pas de filtre => tout est visible ou on le cache
  // map.setLayoutProperty(layerId, 'visibility', 'none');
  // ou un setFilter(layerId, false)
}

// ----------------------------------------------------------------------------
// Fonctions d'utilisation
// ----------------------------------------------------------------------------

function hideAllLayers() {
  Object.keys(layerConfigs).forEach(layerId => {
    // type choropleth => la vraie couche est layerId-choropleth
    if (layerConfigs[layerId].type === 'choropleth') {
      const cId = `${layerId}-choropleth`;
      if (map.getLayer(cId)) {
        map.setLayoutProperty(cId, 'visibility', 'none');
      }
    } else {
      if (map.getLayer(layerId)) {
        map.setLayoutProperty(layerId, 'visibility', 'none');
      }
    }
  });
}

// Exemple de fonction publique : affiche la couche X
window.updateMapLayers = function(layerId) {
  currentLayerType = layerId;
  selectedFeatures = []; // reset

  hideAllLayers();

  if (layerConfigs[layerId]) {
    addLayer(layerId);

    // Rendre visible
    if (layerConfigs[layerId].type === 'choropleth') {
      map.setLayoutProperty(`${layerId}-choropleth`, 'visibility', 'visible');
    } else {
      map.setLayoutProperty(layerId, 'visibility', 'visible');
    }
  }
};


// ----------------------------------------------------------------------------
// NEW: Gérer l'affichage des carreaux 200m (filterable) => setFilter
// ----------------------------------------------------------------------------

window.updateCarresResult = function(listOfIDs) {
  const layerId = 'carresResult';

  // Ajouter la couche si pas déjà en place
  addLayer(layerId);

  // Rendre visible la couche
  map.setLayoutProperty(layerId, 'visibility', 'visible');

  const config = layerConfigs[layerId];
  map.setFilter(layerId, [
    "in",
    config.idField,
    ["literal", listOfIDs]
  ]);
};

// ----------------------------------------------------------------------------
// Initialize map on page load
// ----------------------------------------------------------------------------
window.onload = initializeMap;





  </script>
</body>
</html>
